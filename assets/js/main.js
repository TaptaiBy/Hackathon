// main.js ‚Äì x·ª≠ l√Ω upload file .gpx v√† hi·ªÉn th·ªã k·∫øt qu·∫£ l√™n dashboard

async function verifyWorkout() {
  // L·∫•y element input file v√† div hi·ªÉn th·ªã k·∫øt qu·∫£
  const fileInput = document.getElementById('gpxFileInput');
  const resultDiv = document.getElementById('mlResult');

  // Ki·ªÉm tra ƒë√£ ch·ªçn file ch∆∞a
  if (!fileInput.files[0]) {
    resultDiv.innerText = '‚ùå Please choose a .gpx file.';
    return;
  }

  // T·∫°o formData ƒë·ªÉ g·ª≠i file l√™n backend
  const formData = new FormData();
  formData.append('file', fileInput.files[0]);

  // Hi·ªán th√¥ng b√°o ƒëang ki·ªÉm tra
  resultDiv.innerText = '‚è≥ Verifying...';

  try {
    // G·ª≠i request t·ªõi backend FastAPI
    const res = await fetch('http://localhost:8000/upload-workout', {
      method: 'POST',
      body: formData,
    });

    // ƒê·ªçc k·∫øt qu·∫£ tr·∫£ v·ªÅ d·∫°ng JSON
    const data = await res.json();

    // X·ª≠ l√Ω k·∫øt qu·∫£
    if (data.result === 'REAL') {
      let html = `‚úÖ Workout verified as REAL<br/>üîó Tx Hash: <a href="https://sepolia.etherscan.io/tx/${data.tx_hash}" target="_blank">${data.tx_hash}</a>`;
      if (data.features) {
        html += `<div style="margin-top:1rem;"><b>Workout Details:</b><ul style="color:#333;background:#fafafa;border-radius:8px;padding:1rem;">`;
        for (const [key, value] of Object.entries(data.features)) {
          html += `<li><b>${key}:</b> ${value}</li>`;
        }
        html += `</ul></div>`;
      }
      resultDiv.innerHTML = html;
      const hashEl = document.querySelector('.character-card .hash');
      if (hashEl && data.tx_hash) hashEl.innerText = data.tx_hash.slice(0,6) + '...' + data.tx_hash.slice(-4);

      // G·ª≠i l√™n smart contract
      sendRecordToContract(data.features);
    } else {
      resultDiv.innerText = '‚ùå Workout was marked as FAKE or invalid data.';
    }
  } catch (err) {
    resultDiv.innerText = '‚ùå Error uploading or backend not running.';
    console.error(err);
  }
}

// ====== H√ÄM G·ª¨I RECORD L√äN SMART CONTRACT (ƒê·ªÇ NGO√ÄI C√ôNG FILE) ======

async function sendRecordToContract(features) {
  try {
    if (!window.ethereum) {
      alert("Please install Metamask to continue!");
      return;
    }
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    const signer = provider.getSigner();

    const contractAddress = "0xd9145CCE52D386f254917e481eB44e9943F39138"; // <-- ƒêi·ªÅn ƒë√∫ng ƒë·ªãa ch·ªâ contract
    const contractABI = [
      "function logActivity(string activityType, string details) public"
    ];
    const contract = new ethers.Contract(contractAddress, contractABI, signer);

    const activityType = "workout";
    const details = JSON.stringify(features);

    const tx = await contract.logActivity(activityType, details);
    console.log("Transaction sent to blockchain:", tx.hash);

    await tx.wait();
    alert("Workout record successfully stored on blockchain!\nTx hash: " + tx.hash);

  } catch (err) {
    // Log to√†n b·ªô object l·ªói ra console (ƒë·ªÉ inspect trong devtools)
    console.error("Full contract transaction error:", err);

    // Hi·ªÉn th·ªã ra popup ƒë·∫ßy ƒë·ªß th√¥ng tin nh·∫•t c√≥ th·ªÉ
    let errorText = "Failed to send workout record to smart contract!\n\n";

    if (err && err.message) errorText += "Message: " + err.message + "\n\n";
    if (err && err.code) errorText += "Code: " + err.code + "\n\n";
    if (err && err.stack) errorText += "Stack:\n" + err.stack + "\n\n";
    if (err && err.reason) errorText += "Reason: " + err.reason + "\n\n";
    if (err && err.data) errorText += "Data: " + JSON.stringify(err.data) + "\n\n";
    if (typeof err === "object") errorText += "Full error JSON:\n" + JSON.stringify(err, null, 2);

    alert(errorText);
}
}
